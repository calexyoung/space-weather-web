import Handlebars from 'handlebars'
import { templateHelpers } from './helpers'
import {
  TemplateConfig,
  TemplateVariables,
  CompiledTemplate,
  RenderContext,
  ValidationResult,
  ValidationResultSchema,
  CompiledTemplateSchema,
} from './schemas'

// Template cache for compiled templates
class TemplateCache {
  private cache = new Map<string, CompiledTemplate>()
  private maxSize = 100
  
  set(key: string, template: CompiledTemplate) {
    if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value
      if (firstKey !== undefined) {
        this.cache.delete(firstKey)
      }
    }
    this.cache.set(key, template)
  }
  
  get(key: string): CompiledTemplate | undefined {
    return this.cache.get(key)
  }
  
  has(key: string): boolean {
    return this.cache.has(key)
  }
  
  delete(key: string): boolean {
    return this.cache.delete(key)
  }
  
  clear(): void {
    this.cache.clear()
  }
  
  size(): number {
    return this.cache.size
  }
}

export class TemplateService {
  private handlebars: typeof Handlebars
  private cache: TemplateCache
  private initialized = false

  constructor() {
    this.handlebars = Handlebars.create()
    this.cache = new TemplateCache()
    this.initialize()
  }

  private initialize() {
    if (this.initialized) return

    // Register all custom helpers
    Object.entries(templateHelpers).forEach(([name, helper]) => {
      this.handlebars.registerHelper(name, helper)
    })

    // Register common partials
    this.registerCommonPartials()

    this.initialized = true
  }

  private registerCommonPartials() {
    // Header partial
    this.handlebars.registerPartial('header', `
# {{combinedHeadline}}

**Generated:** {{formatDate generatedAt "PPP 'at' p 'UTC'"}}
{{#if llmProvider}}**Generated by:** {{llmProvider}}{{#if llmModel}} ({{llmModel}}){{/if}}{{/if}}
{{#if generationTime}}**Generation time:** {{formatNumber (divide generationTime 1000) 2}}s{{/if}}

---
`)

    // Source summary partial
    this.handlebars.registerPartial('sourceSummary', `
{{#if sources}}
## Data Sources

{{#each sources}}
### {{sourceIcon source}} {{source}}
- **Issued:** {{formatDate issuedAt "PPP 'at' p 'UTC'"}}
{{#if sourceUrl}}- **URL:** [{{source}}]({{sourceUrl}}){{/if}}
{{#if qualityScore}}- **Quality:** {{confidenceBar qualityScore}}{{/if}}
{{#if geomagneticLevel}}- **Geomagnetic:** {{hazardLevel geomagneticLevel}}{{/if}}
{{#if radioBlackoutLevel}}- **Radio Blackout:** {{hazardLevel radioBlackoutLevel}}{{/if}}
{{#if radiationStormLevel}}- **Radiation Storm:** {{hazardLevel radiationStormLevel}}{{/if}}

{{/each}}
{{/if}}
`)

    // Risk assessment partial
    this.handlebars.registerPartial('riskAssessment', `
{{#if riskAssessment}}
## Current Risk Assessment

{{#if riskAssessment.geomagnetic}}
**Geomagnetic Activity:** {{riskAssessment.geomagnetic}}
{{/if}}

{{#if riskAssessment.radioBlackout}}
**Radio Communications:** {{riskAssessment.radioBlackout}}
{{/if}}

{{#if riskAssessment.radiationStorm}}
**Radiation Environment:** {{riskAssessment.radiationStorm}}
{{/if}}

{{#if riskAssessment.overall}}
**Overall Assessment:** {{riskAssessment.overall}}
{{/if}}
{{/if}}
`)

    // Footer partial
    this.handlebars.registerPartial('footer', `
---

*This report was automatically generated from multiple space weather data sources. For the most current information, please consult official sources directly.*
`)
  }

  /**
   * Validate a template for syntax errors and required variables
   */
  validateTemplate(template: string, requiredVars: string[] = []): ValidationResult {
    const errors: ValidationResult['errors'] = []
    const warnings: string[] = []
    const foundVariables = new Set<string>()

    try {
      // Try to parse the template to check for syntax errors
      const ast = this.handlebars.parse(template)
      
      // Extract variables from AST
      const extractVariables = (node: any) => {
        if (node.type === 'MustacheStatement' || node.type === 'BlockStatement') {
          if (node.path && node.path.original) {
            foundVariables.add(node.path.original)
          }
        }
        
        // Recursively check child nodes
        if (node.program) extractVariables(node.program)
        if (node.inverse) extractVariables(node.inverse)
        if (node.body) {
          node.body.forEach((child: any) => extractVariables(child))
        }
      }

      extractVariables(ast)

      // Check for missing required variables
      for (const required of requiredVars) {
        if (!foundVariables.has(required)) {
          errors.push({
            type: 'variable',
            message: `Required variable '${required}' not found in template`,
            severity: 'error',
          })
        }
      }

      // Check for potentially undefined helpers
      const customHelpers = Object.keys(templateHelpers)
      const builtInHelpers = ['if', 'unless', 'each', 'with', 'lookup', 'log']
      const allHelpers = [...customHelpers, ...builtInHelpers]
      
      // Only warn about variables that are not helpers or required variables
      for (const variable of foundVariables) {
        if (!allHelpers.includes(variable) && !requiredVars.includes(variable)) {
          // Skip common template variables that might be defined by the context
          const commonVars = [
            'this', '@index', '@key', '@first', '@last', '@root',
            'source', 'confidence', 'headline', 'summary', 'details',
            'geomagneticLevel', 'radioBlackoutLevel', 'radiationStormLevel',
            'geomagneticText', 'radioBlackoutText', 'radiationStormText',
            'validStart', 'validEnd', 'sourceUrl', 'qualityScore',
            'solarActivity', 'geomagneticActivity', 'radiationEnvironment',
            'riskAssessment', 'recommendations', 'llmProvider', 'llmModel',
            'generationTime', 'confidenceScore', 'processingErrors',
            'issuedAt', 'fetchedAt'
          ]
          
          if (!commonVars.includes(variable) && !variable.includes('.')) {
            warnings.push(`Variable or helper '${variable}' may not be defined`)
          }
        }
      }

    } catch (error) {
      errors.push({
        type: 'syntax',
        message: error instanceof Error ? error.message : 'Template syntax error',
        severity: 'error',
      })
    }

    return ValidationResultSchema.parse({
      isValid: errors.length === 0,
      errors,
      warnings,
      requiredVariables: Array.from(foundVariables).filter(v => requiredVars.includes(v)),
      optionalVariables: Array.from(foundVariables).filter(v => !requiredVars.includes(v)),
    })
  }

  /**
   * Compile a template and cache the result
   */
  compileTemplate(config: TemplateConfig): CompiledTemplate {
    const cacheKey = `${config.id}-${config.version || '1.0.0'}`
    
    // Check cache first
    if (this.cache.has(cacheKey)) {
      const cached = this.cache.get(cacheKey)!
      return cached
    }

    const errors: string[] = []
    const warnings: string[] = []
    let compiledMarkdown: HandlebarsTemplateDelegate | undefined
    let compiledHtml: HandlebarsTemplateDelegate | undefined

    try {
      // Validate markdown template
      const markdownValidation = this.validateTemplate(
        config.markdownTemplate,
        config.requiredVariables
      )
      
      if (!markdownValidation.isValid) {
        errors.push(...markdownValidation.errors.map(e => e.message))
      }
      warnings.push(...markdownValidation.warnings)

      // Compile markdown template
      if (markdownValidation.isValid) {
        compiledMarkdown = this.handlebars.compile(config.markdownTemplate)
      }

      // Compile HTML template if provided
      if (config.htmlTemplate) {
        const htmlValidation = this.validateTemplate(
          config.htmlTemplate,
          config.requiredVariables
        )
        
        if (!htmlValidation.isValid) {
          errors.push(...htmlValidation.errors.map(e => e.message))
        }
        warnings.push(...htmlValidation.warnings)

        if (htmlValidation.isValid) {
          compiledHtml = this.handlebars.compile(config.htmlTemplate)
        }
      }

    } catch (error) {
      errors.push(error instanceof Error ? error.message : 'Compilation failed')
    }

    const compiled = CompiledTemplateSchema.parse({
      templateId: config.id,
      compiledMarkdown,
      compiledHtml,
      compiledAt: new Date(),
      isValid: errors.length === 0,
      errors,
      warnings,
    })

    // Cache the compiled template
    this.cache.set(cacheKey, compiled)
    
    return compiled
  }

  /**
   * Render a template with provided variables
   */
  renderTemplate(
    template: CompiledTemplate,
    variables: TemplateVariables,
    format: 'markdown' | 'html' = 'markdown'
  ): string {
    if (!template.isValid) {
      throw new Error(`Template is invalid: ${template.errors.join(', ')}`)
    }

    const compiledTemplate = format === 'html' ? template.compiledHtml : template.compiledMarkdown
    
    if (!compiledTemplate) {
      throw new Error(`No ${format} template compiled for ${template.templateId}`)
    }

    try {
      // Add helper methods to variables for template access
      const contextVariables = {
        ...variables,
        // Add some computed values
        sourceCount: variables.sources?.length || 0,
        hasHighRisk: variables.sources?.some(s => 
          s.geomagneticLevel && ['G4', 'G5'].includes(s.geomagneticLevel) ||
          s.radioBlackoutLevel && ['R4', 'R5'].includes(s.radioBlackoutLevel) ||
          s.radiationStormLevel && ['S4', 'S5'].includes(s.radiationStormLevel)
        ) || false,
        generationTimeSeconds: variables.generationTime ? variables.generationTime / 1000 : undefined,
      }

      return compiledTemplate(contextVariables) as string
    } catch (error) {
      throw new Error(`Template rendering failed: ${error instanceof Error ? error.message : 'Unknown error'}`)
    }
  }

  /**
   * Render template from configuration and variables
   */
  render(config: TemplateConfig, variables: TemplateVariables, format: 'markdown' | 'html' = 'markdown'): string {
    const compiled = this.compileTemplate(config)
    return this.renderTemplate(compiled, variables, format)
  }

  /**
   * Register a custom helper
   */
  registerHelper(name: string, helper: (...args: unknown[]) => unknown) {
    this.handlebars.registerHelper(name, helper)
  }

  /**
   * Register a custom partial
   */
  registerPartial(name: string, partial: string) {
    this.handlebars.registerPartial(name, partial)
  }

  /**
   * Clear template cache
   */
  clearCache() {
    this.cache.clear()
  }

  /**
   * Get cache statistics
   */
  getCacheStats() {
    return {
      size: this.cache.size(),
      maxSize: 100,
    }
  }

  /**
   * Precompile commonly used templates
   */
  precompileTemplates(templates: TemplateConfig[]) {
    const results = templates.map(template => {
      try {
        const compiled = this.compileTemplate(template)
        return { templateId: template.id, success: compiled.isValid, errors: compiled.errors }
      } catch (error) {
        return {
          templateId: template.id,
          success: false,
          errors: [error instanceof Error ? error.message : 'Precompilation failed']
        }
      }
    })

    return results
  }

  /**
   * Get template AST for debugging
   */
  getTemplateAST(template: string) {
    try {
      return this.handlebars.parse(template)
    } catch (error) {
      throw new Error(`Failed to parse template: ${error instanceof Error ? error.message : 'Unknown error'}`)
    }
  }

  /**
   * Test template with sample data
   */
  testTemplate(config: TemplateConfig, sampleData: Partial<TemplateVariables>): {
    success: boolean
    markdown?: string
    html?: string
    errors: string[]
    warnings: string[]
  } {
    try {
      const compiled = this.compileTemplate(config)
      
      if (!compiled.isValid) {
        return {
          success: false,
          errors: compiled.errors,
          warnings: compiled.warnings,
        }
      }

      // Create minimal test data
      const testVariables: TemplateVariables = {
        generatedAt: new Date(),
        sources: [],
        combinedHeadline: 'Test Space Weather Report',
        executiveSummary: 'This is a test summary.',
        forecast72h: 'Test forecast for the next 72 hours.',
        ...sampleData,
      }

      const markdown = compiled.compiledMarkdown ? 
        this.renderTemplate(compiled, testVariables, 'markdown') : undefined

      const html = compiled.compiledHtml ? 
        this.renderTemplate(compiled, testVariables, 'html') : undefined

      return {
        success: true,
        markdown,
        html,
        errors: compiled.errors,
        warnings: compiled.warnings,
      }

    } catch (error) {
      return {
        success: false,
        errors: [error instanceof Error ? error.message : 'Template test failed'],
        warnings: [],
      }
    }
  }
}

// Create singleton instance
export const templateService = new TemplateService()

// Export for testing
export { TemplateCache }