import { NextRequest, NextResponse } from 'next/server';

export async function POST(request: NextRequest) {
  try {
    const { eventChain, analyst = 'Space Weather AI', format = 'markdown' } = await request.json();

    if (!eventChain || !eventChain.linkedEvents || eventChain.linkedEvents.length === 0) {
      return NextResponse.json(
        { success: false, error: 'Invalid event chain provided' },
        { status: 400 }
      );
    }

    // Generate PEARS-style report
    const report = generateEventChainReport(eventChain, analyst);

    // Format based on requested format
    let formattedReport = report;
    if (format === 'html') {
      formattedReport = markdownToHtml(report);
    } else if (format === 'json') {
      formattedReport = {
        metadata: {
          generatedBy: analyst,
          generatedAt: new Date().toISOString(),
          eventCount: eventChain.eventCount,
          timeSpan: eventChain.timeSpan,
          eventTypes: eventChain.eventTypes
        },
        summary: extractSummary(report),
        fullReport: report,
        eventChain: eventChain
      };
    }

    return NextResponse.json({
      success: true,
      report: formattedReport,
      format,
      metadata: {
        generatedBy: analyst,
        generatedAt: new Date().toISOString(),
        eventCount: eventChain.eventCount,
        timeSpan: eventChain.timeSpan
      }
    });

  } catch (error) {
    console.error('Error generating event chain report:', error);
    return NextResponse.json(
      { 
        success: false, 
        error: 'Failed to generate event chain report',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}

function generateEventChainReport(eventChain: any, analyst: string): string {
  const { linkedEvents, eventCount, timeSpan, eventTypes } = eventChain;
  const sortedEvents = linkedEvents.sort((a: any, b: any) => 
    new Date(a.beginTime).getTime() - new Date(b.beginTime).getTime()
  );

  const startTime = new Date(sortedEvents[0].beginTime);
  const endTime = new Date(sortedEvents[sortedEvents.length - 1].beginTime);

  return `# Post Event Analysis Report (PEARS)

## Event Chain Analysis
**Generated by:** ${analyst}  
**Generated on:** ${new Date().toISOString()}  
**Analysis Period:** ${startTime.toISOString()} - ${endTime.toISOString()}

---

## Executive Summary

This report analyzes a space weather event chain consisting of **${eventCount} interconnected events** spanning **${timeSpan.toFixed(1)} hours**. The event sequence includes the following phenomena: ${eventTypes.join(', ')}.

The analysis reveals a classical space weather progression beginning with solar activity and cascading through the heliosphere to Earth's magnetosphere, demonstrating the interconnected nature of space weather events.

---

## Event Overview

### Key Characteristics
- **Total Events:** ${eventCount}
- **Event Types:** ${eventTypes.join(', ')}
- **Time Span:** ${timeSpan.toFixed(1)} hours
- **Analysis Method:** Event linkage analysis using DONKI database

### Event Classification
${eventTypes.map(type => `- **${type}**: ${getEventTypeDescription(type)}`).join('\n')}

---

## Chronological Timeline

${sortedEvents.map((event: any, index: number) => {
  const eventTime = new Date(event.beginTime);
  const relativeTime = index === 0 ? 'T+0h' : `T+${((eventTime.getTime() - startTime.getTime()) / (1000 * 60 * 60)).toFixed(1)}h`;
  
  return `### ${index + 1}. [${event.eventType}] ${event.beginTime}
**Relative Time:** ${relativeTime}  
**Event ID:** \`${event.eventID}\`  
${formatEventDetails(event)}
${event.linkedEvents && event.linkedEvents.length > 0 ? 
  `**Linked to:** ${event.linkedEvents.map((link: any) => link.activityID).join(', ')}` : 
  '**Isolated Event**'}
`;
}).join('\n')}

---

## Detailed Analysis

### Linkage Pattern Analysis
The event chain demonstrates a ${determineLinkagePattern(sortedEvents)} linkage pattern:

${analyzeLinkagePatterns(sortedEvents)}

### Temporal Analysis
- **Onset Time:** ${startTime.toISOString()}
- **Duration:** ${timeSpan.toFixed(1)} hours
- **Event Frequency:** ${(eventCount / (timeSpan / 24)).toFixed(2)} events per day during active period

### Source Region Analysis
${analyzeSourceRegions(sortedEvents)}

### Propagation Analysis
${analyzePropagation(sortedEvents)}

---

## Space Weather Impact Assessment

### Geomagnetic Effects
${assessGemagneticImpacts(sortedEvents)}

### Radiation Environment
${assessRadiationEnvironment(sortedEvents)}

### Technology Impacts
${assessTechnologyImpacts(sortedEvents)}

---

## Conclusions

1. **Event Sequence Classification:** ${classifyEventSequence(eventTypes, timeSpan)}

2. **Physical Interpretation:** ${generatePhysicalInterpretation(sortedEvents)}

3. **Forecasting Implications:** ${generateForecastingImplications(sortedEvents)}

4. **Monitoring Recommendations:** ${generateMonitoringRecommendations(eventTypes)}

---

## References and Data Sources

- NASA Goddard Space Flight Center DONKI Database
- NOAA Space Weather Prediction Center
- Event data accessed on ${new Date().toISOString()}

---

*This report was generated automatically using the Space Weather Dashboard Event Chain Analysis system. For questions or clarifications, please contact the Space Weather Operations team.*
`;
}

function getEventTypeDescription(type: string): string {
  const descriptions = {
    'FLR': 'Solar Flare - Sudden release of electromagnetic energy from solar active regions',
    'CME': 'Coronal Mass Ejection - Large-scale solar plasma and magnetic field release',
    'SEP': 'Solar Energetic Particle - High-energy particle acceleration and propagation',
    'IPS': 'Interplanetary Shock - Fast-moving disturbance in solar wind',
    'GST': 'Geomagnetic Storm - Disturbance of Earth\'s magnetosphere',
    'MPC': 'Magnetopause Crossing - Boundary crossing of Earth\'s magnetosphere',
    'RBE': 'Radiation Belt Enhancement - Increase in trapped particle populations'
  };
  return descriptions[type as keyof typeof descriptions] || 'Unknown event type';
}

function formatEventDetails(event: any): string {
  const details = [];
  
  if (event.classType) details.push(`**Class:** ${event.classType}`);
  if (event.sourceLocation) details.push(`**Source:** ${event.sourceLocation}`);
  if (event.activeRegionNum) details.push(`**Active Region:** ${event.activeRegionNum}`);
  if (event.speed) details.push(`**Speed:** ${event.speed} km/s`);
  if (event.halfAngle) details.push(`**Half-Angle:** ${event.halfAngle}Â°`);
  if (event.peakTime) details.push(`**Peak Time:** ${event.peakTime}`);
  if (event.endTime) details.push(`**End Time:** ${event.endTime}`);
  
  return details.join('  \n');
}

function determineLinkagePattern(events: any[]): string {
  if (events.length <= 2) return 'simple';
  
  const linkageCounts = events.map(e => e.linkedEvents?.length || 0);
  const maxLinks = Math.max(...linkageCounts);
  const avgLinks = linkageCounts.reduce((a, b) => a + b, 0) / linkageCounts.length;
  
  if (maxLinks > 3) return 'complex multi-branch';
  if (avgLinks > 1.5) return 'highly interconnected';
  return 'sequential cascade';
}

function analyzeLinkagePatterns(events: any[]): string {
  const totalLinks = events.reduce((sum, event) => sum + (event.linkedEvents?.length || 0), 0) / 2; // Divide by 2 to avoid double counting
  const connectivity = totalLinks / events.length;
  
  return `The ${events.length} events show ${totalLinks} total linkages, representing a connectivity ratio of ${connectivity.toFixed(2)}. This indicates a ${connectivity > 1.5 ? 'highly connected' : connectivity > 1.0 ? 'moderately connected' : 'loosely connected'} event sequence.`;
}

function analyzeSourceRegions(events: any[]): string {
  const sourceRegions = events
    .filter(e => e.sourceLocation)
    .map(e => e.sourceLocation);
  
  if (sourceRegions.length === 0) return 'Source region information not available for this event chain.';
  
  const uniqueRegions = [...new Set(sourceRegions)];
  
  if (uniqueRegions.length === 1) {
    return `All events originate from a single source region: **${uniqueRegions[0]}**, indicating a concentrated area of solar activity.`;
  } else {
    return `Events originate from multiple source regions: ${uniqueRegions.join(', ')}, suggesting distributed solar activity.`;
  }
}

function analyzePropagation(events: any[]): string {
  const cmeEvents = events.filter(e => e.eventType === 'CME');
  const ipsEvents = events.filter(e => e.eventType === 'IPS');
  
  if (cmeEvents.length > 0 && ipsEvents.length > 0) {
    const cmeTime = new Date(cmeEvents[0].beginTime);
    const ipsTime = new Date(ipsEvents[0].beginTime);
    const transitTime = (ipsTime.getTime() - cmeTime.getTime()) / (1000 * 60 * 60);
    
    return `CME-to-shock transit time of approximately **${transitTime.toFixed(1)} hours**, consistent with ${transitTime < 24 ? 'fast' : transitTime < 48 ? 'moderate' : 'slow'} solar wind propagation.`;
  }
  
  return 'Propagation analysis requires both CME and interplanetary shock observations.';
}

function assessGemagneticImpacts(events: any[]): string {
  const gstEvents = events.filter(e => e.eventType === 'GST');
  const cmeEvents = events.filter(e => e.eventType === 'CME');
  
  if (gstEvents.length > 0) {
    return 'Geomagnetic storm conditions observed, with potential impacts on navigation systems, power grids, and satellite operations.';
  } else if (cmeEvents.length > 0) {
    return 'CME events present - monitor for potential geomagnetic effects upon Earth arrival.';
  }
  
  return 'No significant geomagnetic impacts expected from this event sequence.';
}

function assessRadiationEnvironment(events: any[]): string {
  const sepEvents = events.filter(e => e.eventType === 'SEP');
  const flareEvents = events.filter(e => e.eventType === 'FLR' && e.classType?.startsWith('M') || e.classType?.startsWith('X'));
  
  if (sepEvents.length > 0) {
    return 'Solar energetic particle enhancement detected - increased radiation hazard for aviation and spacecraft operations.';
  } else if (flareEvents.length > 0) {
    return 'Significant solar flare activity present - monitor for potential SEP events and radiation effects.';
  }
  
  return 'Radiation environment within normal parameters for this event sequence.';
}

function assessTechnologyImpacts(events: any[]): string {
  const impacts = [];
  
  if (events.some(e => e.eventType === 'FLR' && (e.classType?.startsWith('M') || e.classType?.startsWith('X')))) {
    impacts.push('HF radio communications disruption');
  }
  
  if (events.some(e => e.eventType === 'SEP')) {
    impacts.push('Aviation radiation exposure');
    impacts.push('Spacecraft charging and component damage');
  }
  
  if (events.some(e => e.eventType === 'GST')) {
    impacts.push('GNSS/GPS accuracy degradation');
    impacts.push('Power grid instabilities');
  }
  
  if (impacts.length === 0) {
    return 'Minimal technology impacts expected from this event sequence.';
  }
  
  return `Potential technology impacts include: ${impacts.join(', ')}.`;
}

function classifyEventSequence(eventTypes: string[], timeSpan: number): string {
  if (eventTypes.includes('FLR') && eventTypes.includes('CME') && eventTypes.includes('IPS')) {
    return 'Complete Sun-to-Earth event chain';
  } else if (eventTypes.includes('FLR') && eventTypes.includes('CME')) {
    return 'Solar eruptive event sequence';
  } else if (eventTypes.includes('IPS') && eventTypes.includes('GST')) {
    return 'Interplanetary-to-magnetospheric coupling';
  }
  
  return 'Partial space weather event sequence';
}

function generatePhysicalInterpretation(events: any[]): string {
  const hasFlare = events.some(e => e.eventType === 'FLR');
  const hasCME = events.some(e => e.eventType === 'CME');
  const hasSEP = events.some(e => e.eventType === 'SEP');
  
  if (hasFlare && hasCME && hasSEP) {
    return 'Classical magnetic reconnection event leading to plasma ejection and particle acceleration, demonstrating the multi-faceted nature of solar eruptions.';
  } else if (hasFlare && hasCME) {
    return 'Magnetically driven solar eruption with associated plasma expulsion, typical of active region destabilization.';
  }
  
  return 'Event sequence consistent with solar magnetic field restructuring and energy release processes.';
}

function generateForecastingImplications(events: any[]): string {
  return 'This event pattern provides valuable insights for space weather forecasting models, particularly regarding event onset timing, propagation characteristics, and cascade effects. The observed linkages can improve predictive algorithms for similar solar-terrestrial sequences.';
}

function generateMonitoringRecommendations(eventTypes: string[]): string {
  const recommendations = [];
  
  if (eventTypes.includes('FLR')) {
    recommendations.push('Continue solar X-ray monitoring for additional flare activity');
  }
  
  if (eventTypes.includes('CME')) {
    recommendations.push('Monitor coronagraph imagery for additional CME launches');
    recommendations.push('Track interplanetary propagation using solar wind monitors');
  }
  
  if (eventTypes.includes('SEP')) {
    recommendations.push('Maintain enhanced radiation monitoring for aviation and space assets');
  }
  
  return recommendations.length > 0 ? recommendations.join('; ') + '.' : 'Continue routine space weather monitoring protocols.';
}

function markdownToHtml(markdown: string): string {
  // Simple markdown to HTML conversion
  return markdown
    .replace(/^# (.*$)/gim, '<h1>$1</h1>')
    .replace(/^## (.*$)/gim, '<h2>$1</h2>')
    .replace(/^### (.*$)/gim, '<h3>$1</h3>')
    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
    .replace(/\*(.*?)\*/g, '<em>$1</em>')
    .replace(/`(.*?)`/g, '<code>$1</code>')
    .replace(/^\- (.*$)/gim, '<li>$1</li>')
    .replace(/\n\n/g, '</p><p>')
    .replace(/^(.*)$/gim, '<p>$1</p>')
    .replace(/<p><li>/g, '<ul><li>')
    .replace(/<\/li><\/p>/g, '</li></ul>');
}

function extractSummary(report: string): string {
  const lines = report.split('\n');
  const summaryStart = lines.findIndex(line => line.includes('Executive Summary'));
  const summaryEnd = lines.findIndex((line, index) => index > summaryStart && line.startsWith('---'));
  
  if (summaryStart !== -1 && summaryEnd !== -1) {
    return lines.slice(summaryStart + 1, summaryEnd).join('\n').trim();
  }
  
  return 'Executive summary not found';
}